/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 */
/**
 * generated by Xtext 2.10.0
 */
package org.thingml.xtext.ui.quickfix;

import com.google.common.base.Objects;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModification;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.eclipse.xtext.xbase.lib.CollectionExtensions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.thingml.xtext.constraints.ThingMLHelpers;
import org.thingml.xtext.thingML.AbstractConnector;
import org.thingml.xtext.thingML.ActionBlock;
import org.thingml.xtext.thingML.Configuration;
import org.thingml.xtext.thingML.Connector;
import org.thingml.xtext.thingML.Expression;
import org.thingml.xtext.thingML.ExternalConnector;
import org.thingml.xtext.thingML.Function;
import org.thingml.xtext.thingML.Instance;
import org.thingml.xtext.thingML.Parameter;
import org.thingml.xtext.thingML.Port;
import org.thingml.xtext.thingML.RequiredPort;
import org.thingml.xtext.thingML.State;
import org.thingml.xtext.thingML.StateContainer;
import org.thingml.xtext.thingML.Thing;
import org.thingml.xtext.thingML.ThingMLFactory;
import org.thingml.xtext.thingML.TypeRef;

/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
@SuppressWarnings("all")
public class ThingMLQuickfixProvider extends DefaultQuickfixProvider {
  @Fix("state-sink")
  public void makeStateFinal(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Change state " + _get);
    String _plus_1 = (_plus + " to a final state");
    final IModification _function = (IModificationContext context) -> {
      context.getXtextDocument().replace((issue.getOffset()).intValue(), 0, "final ");
    };
    acceptor.accept(issue, 
      "Make state final", _plus_1, 
      "", _function);
  }
  
  @Fix("type-cast")
  public void cast(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Cast to " + _get);
    String _get_1 = issue.getData()[0];
    String _plus_1 = ("Cast this expression to " + _get_1);
    final IModification _function = (IModificationContext context) -> {
      IXtextDocument _xtextDocument = context.getXtextDocument();
      Integer _offset = issue.getOffset();
      Integer _length = issue.getLength();
      int _plus_2 = ((_offset).intValue() + (_length).intValue());
      String _get_2 = issue.getData()[0];
      String _plus_3 = (" as " + _get_2);
      _xtextDocument.replace(_plus_2, 0, _plus_3);
    };
    acceptor.accept(issue, _plus, _plus_1, 
      "", _function);
  }
  
  @Fix("required-ports-not-connected")
  public void makeOptional(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Make port " + _get);
    String _plus_1 = (_plus + " optional");
    String _get_1 = issue.getData()[0];
    String _plus_2 = ("Make port " + _get_1);
    String _plus_3 = (_plus_2 + " optional");
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Configuration)) {
        final Configuration cfg = ((Configuration) obj);
        final String iName = issue.getData()[0].split("/")[0];
        final Function1<Instance, Boolean> _function_1 = (Instance i) -> {
          String _name = i.getName();
          return Boolean.valueOf(Objects.equal(_name, iName));
        };
        final Instance i = IterableExtensions.<Instance>findFirst(cfg.getInstances(), _function_1);
        final String pName = issue.getData()[0].split("/")[1];
        final Function1<Port, Boolean> _function_2 = (Port p) -> {
          return Boolean.valueOf((((p instanceof RequiredPort) && (!((RequiredPort) p).isOptional())) && Objects.equal(p.getName(), pName)));
        };
        Port _findFirst = IterableExtensions.<Port>findFirst(ThingMLHelpers.allPorts(i.getType()), _function_2);
        final RequiredPort p = ((RequiredPort) _findFirst);
        p.setOptional(true);
      }
    };
    acceptor.accept(issue, _plus_1, _plus_3, 
      "", _function);
  }
  
  @Fix("fragment-instanciation")
  public void makeConcrete(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Make thing " + _get);
    String _plus_1 = (_plus + " concrete");
    String _get_1 = issue.getData()[0];
    String _plus_2 = ("Make thing " + _get_1);
    String _plus_3 = (_plus_2 + " concrete");
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Configuration)) {
        final Configuration cfg = ((Configuration) obj);
        final String iName = issue.getData()[0];
        final Function1<Instance, Boolean> _function_1 = (Instance i) -> {
          String _name = i.getName();
          return Boolean.valueOf(Objects.equal(_name, iName));
        };
        final Instance i = IterableExtensions.<Instance>findFirst(cfg.getInstances(), _function_1);
        Thing _type = i.getType();
        _type.setFragment(false);
      }
    };
    acceptor.accept(issue, _plus_1, _plus_3, 
      "", _function);
  }
  
  @Fix("fragment-instanciation")
  public void removeInstance(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Remove instance " + _get);
    String _get_1 = issue.getData()[0];
    String _plus_1 = ("Remove instance " + _get_1);
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Configuration)) {
        final Configuration cfg = ((Configuration) obj);
        final String iName = issue.getData()[0];
        final Function1<Instance, Boolean> _function_1 = (Instance i) -> {
          String _name = i.getName();
          return Boolean.valueOf(Objects.equal(_name, iName));
        };
        final Instance i = IterableExtensions.<Instance>findFirst(cfg.getInstances(), _function_1);
        final Function1<AbstractConnector, Boolean> _function_2 = (AbstractConnector c) -> {
          if ((c instanceof ExternalConnector)) {
            final ExternalConnector ec = ((ExternalConnector) c);
            Instance _inst = ec.getInst();
            return Boolean.valueOf(Objects.equal(_inst, i));
          } else {
            final Connector conn = ((Connector) c);
            return Boolean.valueOf((Objects.equal(conn.getCli(), i) || Objects.equal(conn.getSrv(), i)));
          }
        };
        final Iterable<AbstractConnector> toBeRemoved = IterableExtensions.<AbstractConnector>filter(cfg.getConnectors(), _function_2);
        CollectionExtensions.<AbstractConnector>removeAll(cfg.getConnectors(), toBeRemoved);
        cfg.getInstances().remove(i);
      }
    };
    acceptor.accept(issue, _plus, _plus_1, 
      "", _function);
  }
  
  @Fix("unreachable-code")
  public void removeUnreachableCode(final Issue issue, final IssueResolutionAcceptor acceptor) {
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof ActionBlock)) {
        final ActionBlock block = ((ActionBlock) obj);
        final int index = Integer.parseInt(issue.getData()[0]);
        while ((block.getActions().size() > (index + 1))) {
          block.getActions().remove((index + 1));
        }
      }
    };
    acceptor.accept(issue, 
      "Remove unreachable code", 
      "Remove unreachable code", 
      "", _function);
  }
  
  @Fix("state-unreachable")
  public void removeState(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Remove state " + _get);
    String _get_1 = issue.getData()[0];
    String _plus_1 = ("Remove state " + _get_1);
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof StateContainer)) {
        final StateContainer sc = ((StateContainer) obj);
        final String sName = issue.getData()[0];
        final Function1<State, Boolean> _function_1 = (State st) -> {
          String _name = st.getName();
          return Boolean.valueOf(Objects.equal(_name, sName));
        };
        final State s = IterableExtensions.<State>findFirst(sc.getSubstate(), _function_1);
        sc.getSubstate().remove(s);
      }
    };
    acceptor.accept(issue, _plus, _plus_1, 
      "", _function);
  }
  
  @Fix("function-never-called")
  public void removeFunction(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _get = issue.getData()[0];
    String _plus = ("Remove function " + _get);
    String _get_1 = issue.getData()[0];
    String _plus_1 = ("Remove function " + _get_1);
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Thing)) {
        final Thing thing = ((Thing) obj);
        final String fName = issue.getData()[0];
        final Function1<Function, Boolean> _function_1 = (Function fun) -> {
          String _name = fun.getName();
          return Boolean.valueOf(Objects.equal(_name, fName));
        };
        final Function f = IterableExtensions.<Function>findFirst(thing.getFunctions(), _function_1);
        thing.getFunctions().remove(f);
      }
    };
    acceptor.accept(issue, _plus, _plus_1, 
      "", _function);
  }
  
  @Fix("abstract-function-fragment")
  public void makeThingFragment(final Issue issue, final IssueResolutionAcceptor acceptor) {
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Thing)) {
        final Thing thing = ((Thing) obj);
        thing.setFragment(true);
      }
    };
    acceptor.accept(issue, 
      "Make thing a fragment", 
      "Make thing a fragment", 
      "", _function);
  }
  
  @Fix("abstract-function-fragment")
  public void makeFunctionConcrete(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _xifexpression = null;
    String[] _data = issue.getData();
    boolean _tripleNotEquals = (_data != null);
    if (_tripleNotEquals) {
      _xifexpression = issue.getData()[0];
    } else {
      _xifexpression = "";
    }
    String _plus = ("Make function " + _xifexpression);
    String _plus_1 = (_plus + " concrete");
    String _xifexpression_1 = null;
    String[] _data_1 = issue.getData();
    boolean _tripleNotEquals_1 = (_data_1 != null);
    if (_tripleNotEquals_1) {
      _xifexpression_1 = issue.getData()[0];
    } else {
      _xifexpression_1 = "";
    }
    String _plus_2 = ("Make function " + _xifexpression_1);
    String _plus_3 = (_plus_2 + " concrete");
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if ((obj instanceof Thing)) {
        final Thing thing = ((Thing) obj);
        final String fName = issue.getData()[0];
        final Function1<Function, Boolean> _function_1 = (Function f) -> {
          return Boolean.valueOf((Objects.equal(f.getName(), fName) && f.isAbstract()));
        };
        final Function f = IterableExtensions.<Function>findFirst(thing.getFunctions(), _function_1);
        f.setAbstract(false);
        final ActionBlock block = ThingMLFactory.eINSTANCE.createActionBlock();
        f.setBody(block);
      }
    };
    acceptor.accept(issue, _plus_1, _plus_3, 
      "", _function);
  }
  
  @Fix("function-not-implemented")
  public void implementFunction(final Issue issue, final IssueResolutionAcceptor acceptor) {
    String _xifexpression = null;
    String[] _data = issue.getData();
    boolean _tripleNotEquals = (_data != null);
    if (_tripleNotEquals) {
      _xifexpression = issue.getData()[0];
    } else {
      _xifexpression = "";
    }
    String _plus = ("Implement function " + _xifexpression);
    String _xifexpression_1 = null;
    String[] _data_1 = issue.getData();
    boolean _tripleNotEquals_1 = (_data_1 != null);
    if (_tripleNotEquals_1) {
      _xifexpression_1 = issue.getData()[0];
    } else {
      _xifexpression_1 = "";
    }
    String _plus_1 = ("Implement function " + _xifexpression_1);
    final ISemanticModification _function = (EObject obj, IModificationContext context) -> {
      if (((issue.getData() != null) && (obj instanceof Thing))) {
        final Thing thing = ((Thing) obj);
        final String fName = issue.getData()[0];
        final Function1<Function, Boolean> _function_1 = (Function f) -> {
          return Boolean.valueOf((Objects.equal(f.getName(), fName) && f.isAbstract()));
        };
        final Function abs = IterableExtensions.<Function>findFirst(ThingMLHelpers.allFunctions(thing), _function_1);
        final Function func = ThingMLFactory.eINSTANCE.createFunction();
        func.setName(abs.getName());
        func.setAbstract(false);
        TypeRef _typeRef = abs.getTypeRef();
        boolean _tripleNotEquals_2 = (_typeRef != null);
        if (_tripleNotEquals_2) {
          final TypeRef typeRef = ThingMLFactory.eINSTANCE.createTypeRef();
          typeRef.setCardinality(EcoreUtil.<Expression>copy(abs.getTypeRef().getCardinality()));
          typeRef.setIsArray(abs.getTypeRef().isIsArray());
          typeRef.setType(abs.getTypeRef().getType());
          func.setTypeRef(typeRef);
        }
        final ActionBlock block = ThingMLFactory.eINSTANCE.createActionBlock();
        func.setBody(block);
        final Consumer<Parameter> _function_2 = (Parameter p) -> {
          final Parameter param = ThingMLFactory.eINSTANCE.createParameter();
          param.setName(p.getName());
          final TypeRef typeRef_1 = ThingMLFactory.eINSTANCE.createTypeRef();
          typeRef_1.setCardinality(EcoreUtil.<Expression>copy(p.getTypeRef().getCardinality()));
          typeRef_1.setIsArray(p.getTypeRef().isIsArray());
          typeRef_1.setType(p.getTypeRef().getType());
          param.setTypeRef(typeRef_1);
          func.getParameters().add(param);
        };
        abs.getParameters().forEach(_function_2);
        thing.getFunctions().add(func);
      }
    };
    acceptor.accept(issue, _plus, _plus_1, 
      "", _function);
  }
}
